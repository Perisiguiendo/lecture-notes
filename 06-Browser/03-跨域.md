# 跨域

### Q&A

Q：为什么会出现跨域问题？

A：出于浏览器的同源策略限制，浏览器会拒绝跨域请求

**注：严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的**

- 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向
- 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签
- 通常浏览器不允许跨域读操作（Cross-origin reads）

Q：什么情况才算作跨域？

A：非同源请求，均为跨域

- 名词解释：**同源 —— 如果两个页面拥有相同的协议（protocol），端口（port）和主机（host），那么这两个页面就属于同一个源（origin）。**



![img01](https://user-gold-cdn.xitu.io/2017/9/19/3d6de65250289eea6b6d3961bb258f12?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



Q：为什么有跨域需求?

A：场景 —— 工程服务化后，不同职责的服务分散在不同的工程中，往往这些工程的域名是不同的，但一个需求可能需要对应到多个服务，这时便需要调用不同服务的接口，因此会出现跨域

### 允许跨域资源嵌入的示例

- `<script src="..."></script>`标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到
- `<link rel="stylesheet" href="...">`标签嵌入CSS。
  - 由于CSS的[松散的语法规则](http://scarybeastsecurity.blogspot.dk/2009/12/generic-cross-browser-cross-domain.html)，CSS的跨域需要一个设置正确的`Content-Type`消息头。不同浏览器有不同的限制： [IE](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/gg622939(v=vs.85)), [Firefox](https://www.mozilla.org/en-US/security/advisories/mfsa2010-46/), [Chrome](http://code.google.com/p/chromium/issues/detail?id=9877), [Safari](https://support.apple.com/zh-cn/HT4070) 和 [Opera](https://www.opera.com/zh-cn/security/advisory/943)
- <img>嵌入图片。支持的图片格式包括PNG，JPEG，GIF，BMP，SVG
- &lt;video>和&lt;audio>嵌入多媒体资源
- &lt;object>, &lt;embed> 和&lt;applet>的插件
- **@font-face** 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）
- &lt;frame>和&lt;iframe>载入的任何资源。站点可以使用`X-Frame-Options`消息头来阻止这种形式的跨域交互

浏览器处于安全方面的考虑,只允许本域名下的接口交互,不同源的客户端脚本,在没有明确授权的情况下,不能读写对方的资源。

限制了一下行为：

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 JS 对象无法获取
- Ajax请求发送不出去


# 如何实现跨域

### JSONP

单纯地为了实现跨域请求而创造的一个 trick。

#### 【实现原理】

虽然因为同源策略的影响，不能通过XMLHttpRequest请求不同域上的数据（Cross-origin reads）。

但是，在页面上引入不同域上的js脚本文件却是可以的（Cross-origin embedding）。

因此在js文件载入完毕之后，触发回调，可以将需要的data作为参数传入。

#### 【实现方式（需前后端配合）】

```js
// 代码：服务器端
const http = require('http')
const url = require('url')

http.createServer((req, res)=>{
  let urlObj = url.parse(req.url, true)
  if(urlObj.pathname === '/getWeather'){
    let data = {city:'杭州',weather:'晴天'}
    res.end(`${urlObj.query.callback}(${JSON.stringify(data)})`)
  }else{
    req.writeHead(404,'404 not found')
    res.end('404 Not Found')
  }
}).listen(2020)

console.log('监听 http://127.0.0.1:2020')


// 前端页面js
<script>
  function showData(data) {
    console.log(data) //
  }
</script>
<script src="http://127.0.0.1:2020/getWeather?callback=showData"></script>
// 在函数showData中即可获得数据
```

#### 【优缺点】

**「JSONP优点」**

- 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制
- 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持
- 并且在请求完毕后可以通过调用callback的方式回传结果。

**「JSONP缺点」**

- 它只支持GET请求而不支持POST等其它类型的HTTP请求
- 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题
- XMLHttpRequest相对于JSONP有着更好的错误处理机制

### CORS

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

CORS 是W3C 推荐的一种新的官方方案，能使服务器支持 XMLHttpRequest 的跨域请求。

CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。

浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

值得注意的是，通常使用CORS时，异步请求会被分为简单请求和非简单请求，非简单请求的区别是会先发一次预检请求。

#### 【简单请求】

使用下列方法之一且没有人为设置对 CORS 安全的首部字段集合之外的其他首部字段：

- GET
- HEAD
- POST
  - 仅当POST方法的Content-Type值等于下列之一才算作简单请求
     - text/plain
     - multipart/form-data
     - application/x-www-form-urlencoded

HTTP的头信息不超出以下几种字段：

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID

请求报文：

```http
GET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/access-control/simpleXSInvocation.html
Origin: http://foo.example
```

请求报文的第10行：**Origin: foo.example** 表明该请求来源于 **foo.exmaple**

响应报文：

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2.0.61 
Access-Control-Allow-Origin: *
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml
```

响应报文的第4行：**Access-Control-Allow-Origin: * **表明该资源可以被任意外域访问



下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

> GET /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0…

上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

> Access-Control-Allow-Origin: http://api.bob.com
> Access-Control-Allow-Credentials: true
> Access-Control-Expose-Headers: FooBar
> Content-Type: text/html; charset=utf-8

上面的头信息之中，有三个与CORS请求相关的字段，都以`Access-Control-`开头。

**（1）Access-Control-Allow-Origin**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）Access-Control-Allow-Credentials**

该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。

**（3）Access-Control-Expose-Headers**

该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

####  withCredentials 属性

上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定`Access-Control-Allow-Credentials`字段。

> Access-Control-Allow-Credentials: true

另一方面，开发者必须在AJAX请求中打开`withCredentials`属性。

> var xhr = new XMLHttpRequest();
> xhr.withCredentials = true;

否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

但是，如果省略`withCredentials`设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭`withCredentials`。

> xhr.withCredentials = false;

需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的Cookie。



#### 【非简单请求】

1. 使用了下面任 一 HTTP 方法：

- PUT
- DELETE
- CONNECT
- OPTIONS
- TRACE
- PATCH

2. 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：

- Accept
- Accept-Language
- Content-Language
- Content-Type (but note the additional requirements below)
- DPR
- Downlink
- Save-Data
- Viewport-Width
- Width

3. Content-Type 的值不属于下列之一:

- application/x-www-form-urlencoded
- multipart/form-data
- text/plain

发送真正请求前会先发送**预检请求**，如图所示：

![img02](https://user-gold-cdn.xitu.io/2017/9/19/7a8b1caf56ca5bcf3df9d2645c1a991f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

第一条OPTIONS为预检请求，中同时携带了下面两个首部字段：

```http
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER
```

预检请求的Request中的Access-Control-Request-Method: POST，是告诉服务器，之后的实际请求将使用POST方式。

Access-Control-Request-Headers 是告诉服务器，实际请求将携带两个自定义请求首部字段：X-PINGOTHER 与 Content-Type。

服务器据此决定，该实际请求是否被允许

预检请求的Response中的

```http
Access-Control-Allow-Origin: [foo.example](http://foo.example/) // 标识可接受的跨域请求源
Access-Control-Allow-Methods: POST, GET, OPTIONS //标识可接受的跨域请求方法,如GET、POST、OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type //标识可接受的跨域请求自定义头
Access-Control-Max-Age: 86400 //标识本次预请求的有效时间（秒），期间内无需再发送预请求
```

XMLHttpRequest 请求可以发送凭证请求（HTTP Cookies 和验证信息），通常**不会**跨域发送凭证信息，但也有一些情况需要打通不同的登录态，因此如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标志位。

比如下面代码，可以把 XMLHttpRequest 的 withCredentials 设置为 true，这样浏览器就能跨域发送凭证信息。

```http
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

服务端返回的响应头中的 Access-Control-Allow-Credentials 字段存在且为 true 时，浏览器才会将响应结果传递给客户端程序。

另外，Access-Control-Allow-Origin 必须指定请求源的域名，否则响应失败。

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://foo.com
Access-Control-Allow-Credentials: true
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

如下图所示为附带身份凭证的请求流程图：

![img03](https://user-gold-cdn.xitu.io/2017/9/19/00b87bfed4895220651e6d26c185d496?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



##### 预检请求

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

下面是一段浏览器的JavaScript脚本。

> var url = ‘http://api.alice.com/cors’;
> var xhr = new XMLHttpRequest();
> xhr.open(‘PUT’, url, true);
> xhr.setRequestHeader(‘X-Custom-Header’, ‘value’);
> xhr.send();

上面代码中，HTTP请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。

> OPTIONS /cors HTTP/1.1
> Origin: http://api.bob.com
> Access-Control-Request-Method: PUT
> Access-Control-Request-Headers: X-Custom-Header
> Host: api.alice.com
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0…

"预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。

#####  预检请求的回应

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

> HTTP/1.1 200 OK
> Date: Mon, 01 Dec 2008 01:15:39 GMT
> Server: Apache/2.0.61 (Unix)
> Access-Control-Allow-Origin: http://api.bob.com
> Access-Control-Allow-Methods: GET, POST, PUT
> Access-Control-Allow-Headers: X-Custom-Header
> Content-Type: text/html; charset=utf-8
> Content-Encoding: gzip
> Content-Length: 0
> Keep-Alive: timeout=2, max=100
> Connection: Keep-Alive
> Content-Type: text/plain

上面的HTTP回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

> Access-Control-Allow-Origin: *

如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

> ```http
> XMLHttpRequest cannot load http://api.alice.com.
> Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
> ```

服务器回应的其他CORS相关字段如下。

> Access-Control-Allow-Methods: GET, POST, PUT
> Access-Control-Allow-Headers: X-Custom-Header
> Access-Control-Allow-Credentials: true
> Access-Control-Max-Age: 1728000

**（1）Access-Control-Allow-Methods**

该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

**（2）Access-Control-Allow-Headers**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

**（3）Access-Control-Allow-Credentials**

该字段与简单请求时的含义相同。

**（4）Access-Control-Max-Age**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

##### 浏览器的正常请求和回应

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

下面是"预检"请求之后，浏览器的正常CORS请求。

> PUT /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> X-Custom-Header: value
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0…

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

> Access-Control-Allow-Origin: http://api.bob.com
> Content-Type: text/html; charset=utf-8

上面头信息中，`Access-Control-Allow-Origin`字段是每次回应都必定包含的。



### postMessage

window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。

```js
otherWindow.postMessage(message, targetOrigin, [transfer]);
```



### nginx反向代理

实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。

使用nginx反向代理实现跨域，是最简单的跨域方式。

只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

实现思路：

**通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。**

先下载nginx，然后将nginx目录下的nginx.conf修改如下:

```nginx
// proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

最后通过命令行`nginx -s reload`启动nginx

```jsx
// index.html
var xhr = new XMLHttpRequest();
// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;
// 访问nginx中的代理服务器
xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);
xhr.send();


// server.js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');
server.on('request', function(req, res) {
    var params = qs.parse(req.url.substring(2));
    // 向前台写cookie
    res.writeHead(200, {
        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取
    });
    res.write(JSON.stringify(params));
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
```



### window.domain

> `window.domain`：获取/设置当前文档的原始域部分。 案例：解决一级域与二级域之间通信。 模拟时需要创建两个不同域的域名用来测试，打开C:\Windows\System32\drivers\etc 该路径下找到 hosts 文件，在最下面创建一个一级域名和一个二级域名。改为：

```
127.0.0.1   www.haoxl.com
127.0.0.1   test.haoxl.com
复制代码
```

> 预设a.html = [www.haoxl.com](http://www.haoxl.com), b.html = [test.haoxl.com](http://test.haoxl.com)

```html
// a.html
<iframe src="http://test.haoxl.com" onload="load()"></iframe>
<script>
function load(){
    //告诉页面它的主域名,要与b.html的主域名相同，这样才可在a中访问b的值
    document.domain = 'haoxl.com'
    function load(){
        // 在a页面引入b页面后，直接通过下面方式获取b中的值
        console.log(frame.contentWindow.a);
    }
}
</script>


// b.html
document.domain = 'haoxl.com'
var a = 'hello world'
```





### WebSocket

> WebSocket对象提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。它是基于TCP的全双工通信,即服务端和客户端可以双向进行通讯，并且允许跨域通讯。基本协议有`ws://`(非加密)和`wss://`(加密)

Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。

> WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 **「WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据」**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

```js
//socket.html
let socket = new WebSocket('ws://localhost:3000');
// 给服务器发消息
socket.onopen = function() {
    socket.send('hello server')
}
// 接收服务器回复的消息
socket.onmessage = function(e) {
    console.log(e.data)
}

// server.js
let express = require('express');
let app = express();
let WebSocket = require('ws');//npm i ws
// 设置服务器域为3000端口
let wss = new WebSocket.Server({port:3000});
//连接
wss.on('connection', function(ws){
    // 接收客户端传来的消息
    ws.on('message', function(data){
        console.log(data);
        // 服务端回复消息
        ws.send('hello client')
    })
})
```





### location.hash

> `window.location` 只读属性，返回一个`Location`对象，其中包含有关文档当前位置的信息。**window.location : 所有字母必须小写！**只要赋给 location 对象一个新值，文档就会使用新的 URL 加载，就好像使用修改后的 URL 调用了[window.location.assign()](https://developer.mozilla.org/zh-CN/docs/Web/API/Location/assign) 一样。需要注意的是，安全设置，如 [CORS（跨域资源共享）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)，可能会限制实际加载新页面。

> 案例：a、b同域,c单独一个域。a现在想访问c：a通过iframe给c传一个hash值，c收到hash值后再创建一个iframe把值通过hash传递给b,b将hash结果放到a的hash值中。

```html
// a.html
<iframe src="http://localhost:4000/c.html#iloveyou"></iframe>
<script>
//接收b传来的hash值
window.onhashchange = function(){
    console.log(location.hash)
}
</script>



// c.html
//接收a传来的hash值
console.log(location.hash)
//创建一个iframe，把回复的消息传给b
let iframe = document.createElement('iframe');
iframe.src='http://localhost:3000/b.html#idontloveyou';
document.body.appendChild(iframe);


//b.html
<script>
//a.html引的c, c又引的b,所以b.parent.parent即是a
window.parent.parent.location.hash = location.hash
</script>
```





### [window.name](http://window.name)

> 页面可能会因某些限制而改变他的源。脚本可以将 `document.domain` 的值设置为其当前域或其当前域的超级域。如果将其设置为其当前域的超级域，则较短的域将用于后续源检查。

> a和b是同域的http://localhost:3000, c是独立的http://localhost:4000。 a通过iframe引入c，[c把值放到window.name](http://xn--cwindow-wk7kf9l7w5cshg.name),再把它的src指向和a同域的b，然后在iframe所在的窗口中即可取出name的值。

```html
// a.html
<iframe src="http://localhost:4000/c.html" onload="load()"></iframe>
<script>
let first = true
function load(){
    if(first){
        let iframe = document.getElementById('iframe');
        // 将a中的iframe再指向b
        iframe.src='http://localhost:3000/b.html';
        first = false;
    }else{
        //在b中则可得到c给窗口发的消息
        console.log(iframe.contentWindow.name);
    }
}
</script>


// c.html
<script>
window.name = 'nice to meet you'
</script>


//server.js
let express = require('express')
let app = express();
app.use(express.static(__dirname));
app.listen(4000);
```





### 2.5 document.domain + iframe

**该方式仅限主域相同，子域不同的跨域应用场景。**

**实现原理：** 两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
 比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。

我们看个例子：页面`a.zf1.cn:3000/a.html`获取页面`b.zf1.cn:3000/b.html`中a的值

```html
// a.html
<body>
 helloa
  <iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"></iframe>
  <script>
    document.domain = 'zf1.cn'
    function load() {
      console.log(frame.contentWindow.a);
    }
  </script>
</body>


// b.html
<body>
   hellob
   <script>
     document.domain = 'zf1.cn'
     var a = 100;
   </script>
</body>
```