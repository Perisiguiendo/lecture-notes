# Web安全

## XSS 攻击

`XSS` 全称是 `Cross Site Scripting`(即`跨站脚本`)，为了和 CSS 区分，故叫它`XSS`。

XSS 攻击是指浏览器中执行恶意脚本（无论是跨域还是同域），从而拿到用户的信息并进行操作。

这些操作一般可以完成下面这些事情：

1. 窃取`Cookie`
2. 监听用户行为，比如输入账号密码后直接发送到黑客服务器
3. 修改 DOM 伪造登录表单
4. 在页面中生成浮窗广告

通常情况，XSS 攻击的实现有三种方式——**存储型**、**反射型**和**文档型**。原理都比较简单，先来介绍一下。

### 存储型

`存储型`，顾名思义就是将恶意脚本存储了起来。

存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。

常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中`直接执行`， 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。

### 反射型💥

`反射型XSS`指的是恶意脚本作为**网络请求的一部分**。

反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。

比如我输入：

```js
http：//sanyuan.com?q=<script>alert("你完蛋了")</script>
```

这样，在服务器端会拿到`q`参数，然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。

之所以叫它`反射型`， 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。

和`存储型`不一样的是，服务器并不会存储这些恶意脚本。

### 文档型

文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后**修改里面的 html 文档**

这样的劫持方式包括`WIFI路由器劫持`或者`本地恶意软件`等。

### 防范措施

明白了三种`XSS`攻击的原理，我们能发现一个共同点： 都是让恶意脚本直接能在浏览器中执行。

那么要防范它，就是要避免这些脚本代码的执行。

为了完成这一点，必须做到**一个信念，两个利用**。

#### 1. 一个信念

千万不要相信任何用户的输入！

无论是在前端和服务端，都要对用户的输入进行**转码**或者**过滤**。

如：

```html
<script>alert('你完蛋了')</script>
```

转码后变为：

```
&lt;script&gt;alert(&#39;你完蛋了&#39;)&lt;/script&gt;
```

这样的代码在 html 解析的过程中是无法执行的。

当然也可以利用关键词过滤的方式，将 script 标签给删除。

#### 2. 利用 CSP

CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能：

1. 限制其他域下的资源加载
2. 禁止向其它域提交数据
3. 提供上报机制，能帮助我们及时发现 XSS 攻击

CSP为内容安全策略，两种方式进行设置，第一种为http头部设置“Content-Security-Policy"，另一种为meta标签内设置http-equiv="Content-Security-Policy"

#### 3. 利用 HttpOnly

很多 XSS 攻击脚本都是用来窃取Cookie， 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值



## CSRF攻击

### 什么是CSRF攻击？

CSRF(Cross-site request forgery)， 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户**目前的登录状态**发起跨站请求。

举个例子， 你在某个论坛点击了一张图片，你点击后，进入了一个新的页面。

那么恭喜你，被攻击了🐷

你可能会比较好奇，怎么突然就被攻击了呢？

接下来我们就来拆解一下当你点击了链接之后，黑客在背后做了哪些事情。

可能会做三样事情。列举如下：

#### 1. 自动发 GET 请求

黑客网页里面可能有一段这样的代码：

```js
<img src="https：//xxx.com/info?user=hhh&count=100">
```

进入页面后自动发送 GET请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息（这里是假定你已经在 xxx.com 中登录过）。

假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。

#### 2. 自动发 POST 请求

黑客可能自己填了一个表单，写了一段自动提交的脚本。

```html
<form id='hacker-form' action="https：//xxx.com/info" method="POST">
  <input type="hidden" name="user" value="hhh" />
  <input type="hidden" name="count" value="100" />
</form>
<script>document.getElementById('hacker-form').submit();</script>
```

同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。

#### 3. 诱导点击发送 GET 请求

在黑客的网站上，可能会放上一个链接，驱使你来点击：

```html
<a href="https：//xxx/info?user=hhh&count=100" taget="_blank">点击进入修仙世界</a>
```

点击后，自动发送 get 请求，接下来和`自动发 GET 请求`部分同理。

这就是`CSRF`攻击的原理。

和`XSS`攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的`html`文档中，而是跳转到新的页面，利用服务器的**验证漏洞**和**用户之前的登录状态**来模拟用户进行操作。

### 防范措施

#### 1. 利用Cookie的SameSite属性

`CSRF攻击`中重要的一环就是自动发送目标站点下的 `Cookie`，然后就是这一份 Cookie 模拟了用户的身份。

因此在`Cookie`上面下文章是防范的不二之选。

恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是`SameSite`。

`SameSite`可以设置为三个值，`Strict`、`Lax`和`None`。

- 在`Strict`模式下，浏览器完全禁止第三方请求携带Cookie
  - 比如请求`sanyuan.com`网站只能在`sanyuan.com`域名当中请求才能携带 Cookie，在其他网站请求都不能

- 在`Lax`模式，就宽松一点了，但是只能在 `GET方法提交表单`或者`a 标签发送GET请求`的情况下可以携带 Cookie，其他情况均不能

- 在`None`模式下，也就是默认模式，请求会自动携带上 Cookie

#### 2. 验证来源站点

这就需要用到请求头中的两个字段： **Origin**和**Referer**。

其中，**Origin**只包含域名信息，而**Referer**包含了`具体`的 URL 路径。

当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。

#### 3. CSRF Token

`Django`作为 Python 的一门后端框架，如果是用它开发过的同学就知道，在它的模板（template）中， 开发表单时，经常会附上这样一行代码：

```
{% csrf_token %}
```

这就是`CSRF Token`的典型应用。那它的原理是怎样的呢？

首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。

然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。

这个字符串也就是`CSRF Token`，通常第三方站点无法拿到这个 token， 因此也就是被服务器给拒绝。

可以看看这篇文章，将了Token是怎么操作的👉[彻底理解cookie，session，token](https://zhuanlan.zhihu.com/p/63061864)

Token(令牌)做为Web领域验证身份是一个不错的选择，当然了，JWT有兴趣的也可以去了解一下。

Token步骤如下：

**「第一步:将CSRF Token输出到页面中」**

> 首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了（XSS可能会获取Cookie），否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。

**「第二步:页面提交的请求携带这个Token」**

> 对于GET请求，Token将附在请求地址之后，这样URL 就变成 [http://url](https://link.zhihu.com/?target=http%3A//url)?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上： `<input type=”hidden” name=”csrftoken” value=”tokenvalue”/>` 这样，就把Token以参数的形式加入请求了。

**「第三步：服务器验证Token是否正确」**

> 当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。



##  SQL注入

 SQL是一种结构化查询语言，是一种特殊目的的编程语言，是一种数据库查询和结构设计语言，用于存储数据以及查询、添加、修改和删除数据的操作关系型数据库的语言。

SQL注入是攻击者通过用户在进行http请求的过程中注入恶意的SQL代码，当服务器在使用参数构建数据库SQL命令时，恶意的SQL代码也会被一起构建，并在数据库中执行产生意料之外的结果的攻击行为。 

###  防御：

永远不要使用动态的方式拼接sql，并不轻易信任用户的输入，不把机密信息直接存放。 

##  点击劫持

 是一种视觉欺骗的手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入网页中，并将外观设置为透明，在底部透出一个按钮诱导用户去点击从而跳转到攻击网站。防御方法有两种：X-FRAME-OPTIONS作为http响应头部，可选值有DENY，表示页面不允许任何iframe展示；还有SAMEORIGIN，表示页面可以在相同域名下通过iframe的方法展示。以及ALLOW-FROM，表示页面可以在指定来源的iframe中展示。另一种防御方法时通过JS防御。 

##  中间人攻击

 中间人攻击是攻击人同时与[客户端]()和浏览器端建立联系，并且让对方认为连接是安全可靠的，但实际上整个连接都被攻击者控制，攻击者可以任意获取连接中的信息并改写信息。通常来说不建议使用公共WiFi，因为很可能就会发生中间人攻击的情况，如果在通信的过程中涉及到了某些私密信息就很有可能会被窃取。防御中间人攻击可以通过使用https协议。 