## 防抖逻辑图

![大冰块辛辛苦苦画的图1](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/022c3fa3d8ac4e61a25e515ca66bb127~tplv-k3u1fbpfcp-watermark.image)

### 防抖代码实现

> 函数防抖代码的实现一般是根据`setTimeout`来实现。每次进入都会去执行`setTimeout`，但是如果已经有`setTimeout`在执行，则会先销毁执行的`setTimeout`，再创建一个新的`setTimeout`。保证只有一个`setTimeout`并且在指定时间后执行。

```JavaScript
/**
 * 防抖
 * @param func 
 * @param delay 
 */
function debounce(func: ()=>void, delay: number) {
  let timer: number = 0
  return (...args) => {
    clearTimeout(timer)
    timer = window.setTimeout(() => {
      func(...args)
      timer = 0; // 必须么??
    }, wait)
  }
}


function debounce(fn,delay=500,immediate){
  let timer = null,immediateTimer = null;
  
  return function(){
      let args = arguments, context = this;
      
      // 第一次触发
      if(immediate && !immediateTimer){
      	fn.apply(context,args);
          //重置首次触发标识，否则下个周期执行时会受干扰
          immediateTimer = setTimeout(()=>{
          	immediateTimer = null;
          },delay);
      }
      // 存在多次执行时，重置动作需放在timer中执行；
      if(immediateTimer) clearTimeout(immediateTimer);
      if(timer) clearTimeout(timer);
      
      timer = setTimeout(()=>{
      	fn.apply(context,args);
          timer = null;
          immediateTimer = null;
      },delay);
  }
}

```





## 节流逻辑图

![大冰块辛辛苦苦画的图2](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1892e0a3d5a46229bd5a7f4b21b3bf6~tplv-k3u1fbpfcp-watermark.image)

###  节流代码实现

> 函数节流实现思路是：设置一个初始时间和固定的时间，在固定时间内只会触发一次。触发函数前先对比和初始时间间隔是否大于固定时间，如果两次出发函数的时间间隔大于固定时间，才会触发函数，触发之后初始时间改为触发函数时的时间。

实现方法可以使用时间戳和定时器，明白了思路，方法都是大同小异的。

**以滚动过程每3s触发一次处理函数（时间戳方法）为例：**

```JavaScript
	// 节流初始时间戳
    let pastDate = new Date().valueOf()
    // 点击节流按钮触发函数
    function throttle() {
        let nowDate = new Date().valueOf()
        if (nowDate - pastDate > 3000) {
            console.log('执行节流操作啦~')
            pastDate = new Date().valueOf()
        }
    }
```

#### **总结**

**函数防抖：** 持续点击只有最后一次才触发函数。例如用户滚动页面选点，当用户停止滚动操作才需要触发。

**函数节流：** 一定时间内只触发一次函数。例如表单提交按钮，用户可能会多次点击，造成多次发送数据，我们需要让用户每3s内的所有点击只生效一次。



## 1.5.函数的节流和防抖

| 类型 | 概念                                      | 应用                                  |
| ---- | ----------------------------------------- | ------------------------------------- |
| 节流 | 事件触发后每隔一段时间触发一次,可触发多次 | scroll,resize事件一段时间触发多次     |
| 防抖 | 事件触发动作完成后一段时间触发一次        | scroll,resize事件触发完后一段时间触发 |

节流:

### 1.5.1 节流

```js
    // html 部分
    <style>
    *{padding:0;margin:0;}
    .scroll-box{
        width : 100%;
        height : 500px;
        background:blue;
        overflow : auto;
    }    
    .scroll-item{
        height:1000px;
        width:100%;
    }
    </style>
    <body>
    <div class="scroll-box">
        <div class="scroll-item"></div>
    </div>
    </body>
    
    // js 部分
    let throttle = function (func, delay) {
    let timer = null;
    return function(){
      if (!timer) {
        timer = setTimeout(() => {
          func.apply(this, arguments);
          // 或者直接 func()
          timer = null;
        }, delay);
      }
    };
    };
      
      // 处理函数
      function handle() {
      console.log(arguments)
      console.log(Math.random());
      }
    // 测试用例
    document.getElementsByClassName('scroll-box')[0].addEventListener("scroll", throttle(handle,3000));
```

### 1.5.2 防抖

```js
    // html 部分同上
    // js 部分
    let debounce = function (fn, wait) {
    let timeout = null;
    return function () {
      if (timeout !== null) clearTimeout(timeout);//如果多次触发将上次记录延迟清除掉
      timeout = setTimeout(() => {
        fn.apply(this, arguments);
        // 或者直接 fn()
        timeout = null;
      }, wait);
    };
    }
     // 处理函数
  function handle() {
    console.log(arguments)
    console.log(Math.random());
  }
  // 测试用例
  document.getElementsByClassName('scroll-box')[0].addEventListener("scroll", debounce(handle, 3000));
```

## 

## 第10篇: 能不能实现事件的防抖和节流？

### 节流

节流的核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器`完成`，才能启动**下一个定时器任务**。这就好比公交车，10 分钟一趟，10 分钟内有多少人在公交站等我不管，10 分钟一到我就要发车走人！

代码如下:

```js
function throttle(fn, interval) {
  let flag = true;
  return function(...args) {
    let context = this;
    if (!flag) return;
    flag = false;
    setTimeout(() => {
      fn.apply(context, args);
      flag = true;
    }, interval);
  };
};
复制代码
```

写成下面的方式也是表达一样的意思:

```js
const throttle = function(fn, interval) {
  let last = 0;
  return function (...args) {
    let context = this;
    let now = +new Date();
    // 还没到时间
    if(now - last < interval) return;
    last = now;
    fn.apply(this, args)
  }
}
复制代码
```

### 防抖

核心思想: 每次事件触发则删除原来的定时器，建立新的定时器。跟**王者荣耀**的**回城**功能类似，你反复触发回城功能，那么只认最后一次，从最后一次触发开始计时。

```js
function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    let context = this;
    if(timer) clearTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(context, args);
    }, delay);
  }
}
复制代码
```

### 双剑合璧——加强版节流

现在我们可以把`防抖`和`节流`放到一起，为什么呢？因为防抖有时候触发的太频繁会导致一次响应都没有，我们希望到了固定的时间必须给用户一个响应，事实上很多前端库就是采取了这样的思路。

```js
function throttle(fn, delay) {
  let last = 0, timer = null;
  return function (...args) {
    let context = this;
    let now = new Date();
    if(now - last < delay){
      clearTimeout(timer);
      setTimeout(function() {
        last = now;
        fn.apply(context, args);
      }, delay);
    } else {
      // 这个时候表示时间到了，必须给响应
      last = now;
      fn.apply(context, args);
    }
  }
}
复制代码
```

## 

## 能不能实现事件防抖和节流

### 函数节流(throttle)

> 节流的意思是让函数有节制地执行，而不是毫无节制的触发一次就执行一次。什么叫有节制呢？就是在一段时间内，只执行一次。
>
> 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

抓取一个关键的点：就是执行的时机。要做到控制执行的时机，我们可以通过**「一个开关」**，与定时器setTimeout结合完成。

```js
  function throttle(fn, delay) {
            let flag = true,
                timer = null;
            return function (...args) {
                let context = this;
                if (!flag) return;
                flag = false;
                clearTimeout(timer)
                timer = setTimeout(() => {
                    fn.apply(context, args);
                    flag = true;
                }, delay);
            };
        };
```

### 函数防抖(debounce)

> 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

核心思想：每次事件触发都会删除原有定时器，建立新的定时器。通俗意思就是反复触发函数，只认最后一次，从最后一次开始计时。

代码：

```js
  function debounce(fn, delay) {
            let timer = null
            return function (...args) {
                let context = this
                if(timer)   clearTimeout(timer)
                timer = setTimeout(function() {
                    fn.apply(context, args)
                },delay)
            }
        }
```

### 如何使用 debounce 和 throttle 以及常见的坑

自己造一个 debounce / throttle 的轮子看起来多么诱人，或者随便找个博文复制过来。**「我是建议直接使用 underscore 或 Lodash」** 。如果仅需要 `_.debounce` 和 `_.throttle` 方法，可以使用 Lodash 的自定义构建工具，生成一个 2KB 的压缩库。使用以下的简单命令即可：

```
npm i -g lodash-cli
npm i -g lodash-clilodash-cli include=debounce,throttle
```

常见的坑是，不止一次地调用 `_.debounce` 方法：

```js
// 错误
$(window).on('scroll', function() {
   _.debounce(doSomething, 300); 
});
// 正确
$(window).on('scroll', _.debounce(doSomething, 200));
```

debounce 方法保存到一个变量以后，就可以用它的私有方法 `debounced_version.cancel()`，lodash 和 underscore.js 都有效。

```js
let debounced_version = _.debounce(doSomething, 200);

$(window).on('scroll', debounced_version);


// 如果需要的话debounced_version.cancel();
```

### 适合应用场景

防抖

- search搜索，用户不断输入值时，用防抖来节约Ajax请求,也就是输入框事件。
- window触发resize时，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

节流

- 鼠标的点击事件，比如mousedown只触发一次
- 监听滚动事件，比如是否滑到底部自动加载更多，用throttle判断
- 比如游戏中发射子弹的频率(1秒发射一颗)