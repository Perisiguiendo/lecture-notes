## 函数

### 函数的3种定义方法

#### 函数声明

```javascript
//ES5
function getSum(){}
function (){}       //匿名函数
//ES6
()=>{}              //如果{}内容只有一行{}和return关键字可省,
```

#### 函数表达式(函数字面量)

```javascript
//ES5
var sum=function(){}
//ES6
let sum=()=>{}      //如果{}内容只有一行{}和return关键字可省,
```

#### 构造函数

```javascript
const sum = new Function('a', 'b' , 'return a + b');
```

#### 三种方法的对比

1. 函数声明有预解析，而且函数声明的优先级高于变量; 
2. 使用Function构造函数定义函数的方式是一个函数表达式，这种方式会导致解析两次代码，影响性能。第一次解析常规的JavaScript代码，第二次解析传入构造函数的字符串

### ES5中函数的4种调用

在ES5中函数内容的this指向和调用方法有关

#### 函数调用模式

包括函数名()和匿名函数调用,this指向window

```javascript
 function getSum() {
    console.log(this)        //这个属于函数名调用，this指向window
 }
 getSum()
 
 (function() {
    console.log(this)        //匿名函数调用，this指向window
 })()
 
 var getSum=function() {
    console.log(this)        //实际上也是函数名调用，window
 }
 getSum()
```

#### 方法调用

对象.方法名(),this指向对象

```javascript
var objList = {
   name: 'methods',
   getSum: function() {
     console.log(this)        //objList对象
   }
}
objList.getSum()
```

#### 构造器调用

new 构造函数名(),this指向实例化的对象

```javascript
function Person() {
  console.log(this);           //是构造函数调用，指向实例化的对象personOne
}
var personOne = new Person();
```

#### 间接调用

利用call和apply来实现,this就是call和apply对应的第一个参数,如果不传值或者第一个值为null,undefined时this指向window 通过call/apply如果第一个参数是string、number、boolean，call内部会调用其相应的构造器String、Numer、Boolean将其转换为相应的实例对象

```javascript
function foo() {
   console.log(this);
}
foo.apply('我是apply改变的this值');     //我是apply改变的this值
foo.call('我是call改变的this值');       //我是call改变的this值
```

#### ES6中函数的调用

箭头函数不可以当作构造函数使用，也就是不能用new命令实例化一个对象，否则会抛出一个错误 箭头函数的this是和定义时有关和调用无关 调用就是函数调用模式

```javascript
(() => {
   console.log(this)//window
})()

let arrowFun = () => {
  console.log(this)//window
}
arrowFun()

let arrowObj = {
  arrFun: function() {
   (() => {
     console.log(this)//this指向的是arrowObj对象
   })()
   }
 }
 arrowObj.arrFun();
```



##  箭头函数

```javascript
function Fun(a) {
    this.a = a;
}

let fun = (b) => {
    this.b = b;
}

console.dir(Fun);
console.dir(fun);
console.log(Fun.a);
console.log(fun.b);
```

###  普通函数

![image-20210215211618039](D:\资料\lecture-notes\07-JavaScript\image\image-20210215211618039.png)

###  箭头函数

![image-20210215211712998](D:\资料\lecture-notes\07-JavaScript\image\image-20210215211712998.png)

### ★对比

> **箭头函数表达式**的语法比**函数表达式**更简洁，并且没有自己的**this**，**arguments**，**super**或**new.target**
>
> 箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数

- 没有单独的this
- 不绑定arguments
- 箭头函数不能用作构造器，和 new一起用会抛出错误
- 箭头函数没有prototype属性

- 从上图可以看到箭头函数与构造函数相比，缺少了很多东西，比如：caller，arguments，prototype，但同时也可以看到，箭头函数是有`__proto__`属性的，所以**箭头函数本身是存在原型链的**，他也是有自己的构造函数的，但是原型链到箭头函数这一环就停止了，**因为它自己没有prototype属性**，没法让他的实例的`__proto__`属性指向构造函数的`prototype`，所以**箭头函数也就无法作为构造函数**。
- 同时我们可以看到，由于箭头函数没有自己的this指针，通过 `call()` 或 `apply()` 方法调用一个函数时，只能传递参数，不能绑定this，所以 `call()` 和 `apply()` 的第一个参数会被忽略。

**箭头函数表达式更适用于那些本来需要匿名函数的地方**，那么

## 匿名函数能作为构造函数么？

```javascript
// 定义构造函数
function Fun(a){
    this.a = a
}
// 定义匿名函数并赋予变量
let fun = function(b){
    this.b = b;
}
// 对构造函数实例化
let f1 = new Fun(1);
let f2 = new fun(2);

// 打印结果
console.dir(Fun);
console.dir(f1);
console.log(f1.a);
console.dir(fun);
console.dir(f2);
console.log(f2.b);
```

- 匿名函数因为被赋值给了一个变量，所以在这里可以被看作是普通函数，在这个案例中普通函数和构造函数没有区别
- **构造函数和普通函数不是通过函数名首字母的大小写来区分的，而是通过调用方式来区分的，即new运算符，首字母大写只是约定的习惯。**



## JS 中构造函数和普通函数的区别

1. 构造函数也是一个普通函数，创建方式和普通函数一样，但构造函数习惯上首字母大写
2. 构造函数和普通函数的区别在于：调用方式不一样，作用也不一样（构造函数用来新建实例对象）
3. 调用方式不一样
   - 普通函数的调用方式：直接调用 `person()`
   - 构造函数的调用方式：需要使用 `new` 关键字来调用 `new Person()`
4. 构造函数的函数名与类名相同：Person( ) 这个构造函数，Person 既是函数名，也是这个对象的类名
5. 内部用 this 来构造属性和方法 

```javascript
function Person(name,job,age)
{
    this.name = name;
    this.job = job;
    this.age = age;
    this.sayHi = function(){ alert("Hi") }
} 
```

6. 构造函数的执行流程
   - 立刻在堆内存中创建一个新的对象
   - 将新建的对象设置为函数中的this
   - 逐个执行函数中的代码
   - 将新建的对象作为返回值

7. 普通函数例子：因为没有返回值，所以为 undefined
8. 构造函数例子：构造函数会马上创建一个新对象，并将该新对象作为返回值返回
9. 用instanceof 可以检查一个对象是否是一个类的实例，是则返回true

>  所有对象都是Object对象的后代，所以任何对象和Object做instanceof都会返回true



## 箭头函数有原型函数么？

![image-20210215214614640](D:\资料\lecture-notes\07-JavaScript\image\image-20210215214614640.png)

这里的原型函数应该就是指构造函数的显式原型属性，或者更准确的说法是**箭头函数有它的构造函数么？**

> - 所有的引用类型都有__ proto __属性
> - 只有函数对象有prototype属性
> - 所有的引用类型的__ proto __属性值均指向它的构造函数的prototype的属性值
> - 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去他的__ proto __(即它的构造函数的prototype）中寻找

所以显然**箭头函数是有构造函数的**，但特别的是，它作为一个函数，它是没有prototype属性的。






