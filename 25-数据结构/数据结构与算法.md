## 数据结构与算法

**实现两个变量交换值的方法有哪些 ？**

一、使用临时变量的方法

```
var t; 
t = a; 
a = b; 
b = t;
```

首先把 a 的值存储到临时变量中， 然后 b 赋值给 a， 最后拿出临时变量中的 a 值赋给 b。

二、一次加，两次减

```
a = a + b; 
b = a - b; 
a = a - b;
```

让 a 先变成 a 与 b 的 ‘和’（也可以换成 a 和 b 的差，一样的）， ‘和’ 减去 b ，巧妙的得到了 a 的变量值赋予 b ， 再通过 ‘和’ 减去 a 的值，得到了 b 的值赋予 a 。

三、复用对象 

把 a 先变成了一个对象， 这个对象保存着应该交换后的键值对， 最后赋值搞定。

```
a = { a: b, b: a }; 
b = a.b; 
a = a.a;
```

四、利用数组

和上面的方法很像，只不过对象换成了数组。

```
a = [a, b]; 
b = a[0]; 
a = a[1];
```

五、一行代码

简单粗暴一行代码交换了 a 和 b 的变量值。

```
a = [b, b = a][0];
```

根据运算符优先级，首先执行 b = a ， 此时的 b 直接得到了 a 的变量值 ， 然后一步数组索引让 a 得到了 b 的值（简直不能再厉害）。

六、ES6 的解构赋值语法 

最后我的方案是利用了 ES6 的解构赋值语法， 它允许我们提取数组和对象的值，对变量进行赋值 （旧版本浏览器不能使用ES6语法）。

```
[a, b] = [b, a];
```

------

**原生 js 实现斐波那契数列**

说明： 斐波那契数列，以兔子的繁殖的例子而引入，故又称“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、...； 在数学上，斐波那契数列以如下被以递归的方法定义：F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2) (n>2，n∈N*)。

一、递归方法

```
function f(n) {
  if (n === 1 || n === 2){
    return 1;
  } else {
    return f(n-1) + f(n-2);
  }
}
console.log(f(6));
```

二、动态规划方法（性能得到优化）

```
function f(n) {
    let n1 = 1,
        n2 = 1,
        sum = 1;
    for(let i = 3; i <= n; i += 1) {
        sum = n1 + n2;
        n1 = n2;    // 往后移动一位数
        n2 = sum
    }
    return sum
}
console.log(f(5));
```

------

**求一个数组的最大差值**

原理：遍历一次数组，找到最大值和最小值，返回差值

```
var getMaxProfit = function(arr){
  // 定义两个变量，分别存贮最大值和最小值
  let maxNum = arr[0];
  let minNum = arr[0];
  for(let i = 0; i < arr.length; i++){
    if(arr[i] > maxNum){
      maxNum = arr[i];
    }
    if(arr[i] < minNum){
      minNum = arr[i];
    }
  }
  return maxNum - minNum;
}
```

var max = Math.max.apply(null, array)，这样就可以轻易的得到一个数组中最大的一项 注：在调用 apply 的时候第一个参数给了一个 null，这个是因为没有对象去调用这个方法，我们只需要用这个方法帮我们运算，得到返回的结果就行，所以就直接传递了一个 null 过去。

------

**实现类似 getElementsByClassName 的功能**

自己实现一个函数，查找某个 DOM 节点下面的包含某个 class 的所有 DOM 节点？不允许使用原生提供的 getElementsByClassName、querySelectorAll 等原生提供 DOM 查找函数。

```
function queryClassName(node, name) {  
  var starts = '(^|[ \n\r\t\f])',
       ends = '([ \n\r\t\f]|$)';
  var array = [],
        regex = new RegExp(starts + name + ends),
        elements = node.getElementsByTagName("*"),
        length = elements.length,
        i = 0,
        element;

    while (i < length) {
        element = elements[i];
        if (regex.test(element.className)) {
            array.push(element);
        }
        i += 1;
    }
    return array;
}
```

------

**随机生成指定长度的字符串**

实现一个算法，随机生成指制定长度的字符串。比如给定 长度 8，输出 4ldkfg9j。

原理：可以手动指定字符库及随机字符长度 n，利用 Math.floor() 和 Math.random() 两个方法实现获取随机字符。

```
function randomString(n) {  
  let str = 'abcdefghijklmnopqrstuvwxyz9876543210';
  let tmp = '',
      i = 0,
      l = str.length;
  for (i = 0; i < n; i++) {
    tmp += str.charAt(Math.floor(Math.random() * l));
  }
  return tmp;
}
module.exports = randomString;
```

------

**判断一个单词是否是回文 ？**

回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider 。

很多人拿到这样的题目非常容易想到用 for 将字符串颠倒字母顺序然后匹配就行了。

其实重要的考察的就是对于 reverse 的实现。

其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。

```
function checkPalindrom(str) {  
    return str == str.split('').reverse().join('');
}
```

------

**二分查找算法**

建立在已经排好序的情况下

```
function binarySearch(arr, data) {
    var end = arr.length - 1,
        start = 0;

    while (start <= end) {
        var middle = Math.floor((start + end) / 2);
        if (arr[middle] > data) {
            end = middle - 1;
        } else if (arr[middle] < data) {
            start = middle + 1;
        } else {
            return middle;
        }
    }
    return -1;

}
var arr = [1, 2, 3, 4, 5, 6];
console.log(binarySearch(arr, 2));
```

------

**写一个方法将数组换成前端更易解析的树状结构**

```
function getTree(data) {
    var newData = [],
        hash = {};
    for (var i = 0; i < data.length; i++) {
        if (!hash[data[i].province]) {
            hash[data[i].province] = {
                'province': data[i].province
            };
            hash[data[i].province]['city'] = [{
                'name': data[i].city,
                'code': data[i].code
            }]
            newData.push(hash[data[i].province]);
        } else if (hash[data[i].province].province == data[i].province) {
            hash[data[i].province]['city'].push({
                'name': data[i].city,
                'code': data[i].code
            })
        }
    }
    return newData;
}
 
var data = [{
    'province': '浙江',
    'city': '温州',
    'code': '10010'
}, {
    'province': '浙江',
    'city': '杭州',
    'code': '10011'
}, {
    'province': '安徽',
    'city': '合肥',
    'code': '10012'
}, {
    'province': '安徽',
    'city': '马鞍山',
    'code': '10013'
}, {
    'province': '浙江',
    'city': '宁波',
    'code': '10014'
}];
console.log(getTree(data));
```

------

**数组去重**

一、 使用 ES6 的 Set 去除数组的重复元素

Array.from() 方法可以将 Set 结构转化为数组结构

```
function dedupe(array) { 
  return Array.from(new Set(array)); 
} 
dedupe([1, 2, 3, 3]);
```

二：扩展运算符（…），内部使用 for…of 循环

```
let arr = [1, 2, 3, 3];
let unique = [...new Set(arr)];
```

三：采用对象数组方法去重

```
function sort(arr){
    let obj = {};
    let newArr = [];
    for(let i = 0; i < arr.length; i++){
        if(!obj[arr[i]]){
            obj[arr[i]] = 1;
            newArr.push(arr[i]);
        }
    }
    return newArr;
}
```

------

**字符串反转**

1、split() 字符串转成数组； 2、reverse() 翻转数组； 3、join() 数组转化成字符串。

```
function reverse(str){
    for(let i = 0; i < str.length; i++){
        return str.split('').reverse().join('');
    }
}
```

------

**产生随机数**

```
function random(n){
    let str = '123asdasdasrwer';
    let obj = '';
    var l = str.length;
    for(let i = 0; i < n; i++){
       return obj += str.charAt(Math.floor(Math.random()*l));
    }
}
```

------

**获取地址栏中某个参数的值**

```
function getUrl(){
    let url = window.location.href();
    let Url = url.split('?');
    if(Url[0] == url){
        return '';
    }
    let obj = {};
    let arr = Url[1].split('&');
    for(let i = 0; i < arr.length; i++){
       let arg = arr[i].split('=');
        obj[arg[0]] = arg[1];
    }
    return obj;
}
var href = getUrl();
console.log(href['name']);
```

------

**统计字符中出现次数最多的字母**

原理：这个和数组去重类似，也是利用一个对象 obj，将数组元素作为对象的属性名，如果不存在该属性名，则值赋为 1，如果存在，则值加 1。

```
function findMaxDuplicateChar(str) {
    if(str.length == 1) {
        return str;
    }
    let charObj = {};
    for(let i = 0; i < str.length; i++) {
        // 利用String的charAt()方法获取各个字符; charAt() 方法可返回指定位置的字符
        if(!charObj[str.charAt(i)]) {
            charObj[str.charAt(i)] = 1;
        }else{
            charObj[str.charAt(i)] += 1;
        }
    }
    let maxChar = '',
            maxValue = 1;
    for(var k in charObj) {
        // 在obj对象中寻找值最大的那个属性
        if(charObj[k] >= maxValue) {
            maxChar = k;
            maxValue = charObj[k];
        }
    }
    return maxChar;
}
```

------

**101 个硬币中有 100 真、1 假，真假区别在于重量。请用无砝码天平称两次给出真币重还是假币重的结论**

方法 1

- 第一步：把硬币分为三堆儿（50，50，1），先拿两个 50 放天平比较，如果相等，说明那个单个的就是假的，再随便拿一个真硬币和这个假硬币放天平比较一下就可得到结果。
- 第二步：如果第一步的两个 50 比较后不相等，此时一端 50 重，一端 50 轻。如果拿轻的一端 50，分成两堆（25，25） 放到天平上，如果这两个 25 相等，则假硬币（重）在重的一端 50 里，否则（不相等）假硬币（轻）在这两个（25，25）里，也就是轻的一端 50 里。

方法 2

- 把硬币分为 A B C 三组，满足如下条件：C > A = B，先比较 A 和 B。如果 A 和 B 一样重，则敏感词在 C 中。
- 从 A+B 中选取和 C 同样数量的真币和 C 比较。
- 如果 A 和 B 重量不等，说明 C 中全为真币，从 C 中选取和 A 一样数量的真币与 A 比较，再结合之前 A B 比较的结果，即可得知敏感词究竟比真币重还是轻。

------

- [查找两个不同元素最近的父节点](https://blog.csdn.net/hhthwx/article/details/79784205)

------

#### JavaScript 数据结构

- [JavaScript 数据结构与算法之美 - 线性表（数组、栈、队列、链表）](https://juejin.im/post/5d187b81e51d4550a629b2c5)
- [JavaScript 数据结构与算法之美 - 栈内存与堆内存 、浅拷贝与深拷贝](https://juejin.im/post/5d1b07716fb9a07efe2dd644)
- [JavaScript 数据结构与算法之美 - 非线性表中的树、堆是干嘛用的 ？其数据结构是怎样的 ？](https://juejin.im/post/5d2dd6dc6fb9a07eb67dc34b)

#### 十大经典排序算法

- [JavaScript 数据结构与算法之美 - 十大经典排序算法汇总](https://juejin.im/post/5d3ea9a4e51d4561f060cd2d)