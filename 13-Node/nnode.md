##  Node

**为什么用 Nodejs，它有哪些优缺点 ？**

优点

- 事件驱动，通过闭包很容易实现客户端的生命活期。
- 不用担心多线程，锁，并行计算的问题
- V8 引擎速度非常快
- 对于游戏来说，写一遍游戏逻辑代码，前端后端通用

缺点

- nodejs 更新很快，可能会出现版本兼容
- nodejs 还不算成熟，还没有大制作
- nodejs 不像其他的服务器，对于不同的链接，不支持进程和线程操作

------

**什么是错误优先的回调函数 ？**

错误优先(Error-first)的回调函数（Error-First Callback）用于同时返回错误和数据。 第一个参数返回错误，并且验证它是否出错；其他参数返回数据。

```
fs.readFile(filePath, function(err, data) {
  if (err) { 
    //handle the error
  } 
  // use the data object 
});
```

------

**如何避免回调地狱 ？**

以下方式避免回调地狱

- 模块化：将回调函数转换为独立的函数
- 使用流程控制库，例如 [aync]
- 使用 Promise
- 使用 aync/await

------

**如何用 Node 监听 80 端口 ?**

- 这题有陷阱！在类 Unix 系统中你不应该去监听 80 端口，因为这需要超级用户权限。因此不推荐让你的应用直接监听这个端口。
- 目前，如果你一定要让你的应用 80 端口的话，你可以有通过在 Node 应用的前方再添加一层反向代理（例如 nginx）来实现，如下图。否则，建议你直接监听大于 1024 的端口
- 方向代理指的是以代理服务器来接收 Internet 上的连接请求，然后将请求转发给内部网络上的服务器， 并且将服务器返回的结果发送给客户端。

[![img](https://camo.githubusercontent.com/e43461af38f4fdf1a0e8bcf19fe8cf16af0a6aea04dabcbfecb1de9588ed70d3/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d366238343633363536323939343139302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/e43461af38f4fdf1a0e8bcf19fe8cf16af0a6aea04dabcbfecb1de9588ed70d3/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d366238343633363536323939343139302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

------

**什么是事件循环 ？**

- Node 采用的是单线程的处理机制(所有的 I/O 请求都采用非阻塞的工作方式)，至少从 Node.js 开发者的角度是这样的。而在底层，Node.js 借助 libuv 来作为抽象封装层，从而屏蔽不同操作系统的差异，Node 可以借助 livuv 来实现线程。下图表示 Node 和 libuv 的关系。 [![img](https://camo.githubusercontent.com/7c62cee2e995e7adcb2ab931a29a7da30024de77a1b69364dc253cd7cf4900cf/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d316665393437383764353865373531642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/7c62cee2e995e7adcb2ab931a29a7da30024de77a1b69364dc253cd7cf4900cf/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d316665393437383764353865373531642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)
- Libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给 V8 引擎。可以简单用下面这张图来表示。 [![img](https://camo.githubusercontent.com/24362e4a1ce9859fa9452c3b3b95d97b069ed25ccd041255806c1731225e98b2/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d383135366461666561356530316534362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/24362e4a1ce9859fa9452c3b3b95d97b069ed25ccd041255806c1731225e98b2/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d383135366461666561356530316534362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)
- 每一个 I/O 都需要一个回调函数 ----- 一旦执行完便堆到事件循环上用于执行。