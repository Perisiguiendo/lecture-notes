## 观察者模式

所谓观察者模式，其实就是为了实现**松耦合(loosely coupled)**。

用《Head First设计模式》里的气象站为例子，每当气象测量数据有更新，`changed()`方法就会被调用，于是我们可以在`changed()`方法里面，更新气象仪器上的数据，比如温度、气压等等。

但是这样写有个问题，就是如果以后我们想在`changed()`方法被调用时，更新更多的信息，比如说湿度，那就要去修改`changed()`方法的代码，这就是紧耦合的坏处。

**怎么解决呢？使用观察者模式，面向接口编程，实现松耦合。**

观察者模式里面，`changed()`方法所在的实例对象，就是被观察者（Subject，或者叫Observable），它只需维护一套观察者（Observer）的集合，这些Observer实现相同的接口，Subject只需要知道，通知Observer时，需要调用哪个统一方法就好了：



![img](https://pic2.zhimg.com/80/v2-0a7ef7d1a328dc37eadefb29e0ea705d_720w.jpg)



这里就不贴代码了，网上已经有大量的资料。

## 发布订阅模式

大概很多人都和我一样，觉得发布订阅模式里的Publisher，就是观察者模式里的Subject，而Subscriber，就是Observer。Publisher变化时，就主动去通知Subscriber。

其实并不是。

**在发布订阅模式里，发布者，并不会直接通知订阅者，换句话说，发布者和订阅者，彼此互不相识。**

互不相识？那他们之间如何交流？

**答案是，通过第三者，也就是在消息队列里面，我们常说的经纪人Broker。**



![img](https://pic2.zhimg.com/80/v2-b6ed65f370a766620718ad4227d5d4e5_720w.jpg)



发布者只需告诉Broker，我要发的消息，topic是AAA；

订阅者只需告诉Broker，我要订阅topic是AAA的消息；

于是，当Broker收到发布者发过来消息，并且topic是AAA时，就会把消息推送给订阅了topic是AAA的订阅者。当然也有可能是订阅者自己过来拉取，看具体实现。

**也就是说，发布订阅模式里，发布者和订阅者，不是松耦合，而是完全解耦的。**

放一张极简的图，给大家对比一下这两个模式的区别：



![img](https://pic2.zhimg.com/80/v2-540a78ba3127b0c6882adc668e7a3535_720w.jpg)



## 总结

从表面上看：

- 观察者模式里，只有两个角色 —— 观察者 + 被观察者
- 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— 经纪人Broker

往更深层次讲：

- 观察者和被观察者，是松耦合的关系
- 发布者和订阅者，则完全不存在耦合

从使用层面上讲：

- 观察者模式，多用于单个应用内部
- 发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件







观察者模式（Observer Pattern）
观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。

观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。

发布订阅模式（Pub-Sub Pattern）
其实24种基本的设计模式中并没有发布订阅模式，上面也说了，他只是观察者模式的一个别称。

但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。

在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为消息代理或调度中心或中间件，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。

举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）。

观察者模式和发布订阅模式有什么区别？
我们先来看下这两个模式的实现结构：


观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。

发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。

我们再来看下这两个模式的代码案例：（猎人发布与订阅任务）

观察者模式：

	

```js
    //有一家猎人工会，其中每个猎人都具有发布任务(publish)，订阅任务(subscribe)的功能
	//他们都有一个订阅列表来记录谁订阅了自己
	//定义一个猎人类
	//包括姓名，级别，订阅列表
	function Hunter(name, level){
		this.name = name
		this.level = level
		this.list = []
	}
	Hunter.prototype.publish = function (money){
		console.log(this.level + '猎人' + this.name + '寻求帮助')
	    this.list.forEach(function(item, index){
	    	item(money)
	    })
	}
	Hunter.prototype.subscribe = function (targrt, fn){
		console.log(this.level + '猎人' + this.name + '订阅了' + targrt.name)
	    targrt.list.push(fn)
	}
	
	//猎人工会走来了几个猎人
	let hunterMing = new Hunter('小明', '黄金')
	let hunterJin = new Hunter('小金', '白银')
	let hunterZhang = new Hunter('小张', '黄金')
	let hunterPeter = new Hunter('Peter', '青铜')
	
	//Peter等级较低，可能需要帮助，所以小明，小金，小张都订阅了Peter
	hunterMing.subscribe(hunterPeter, function(money){
		console.log('小明表示：' + (money > 200 ? '' : '暂时很忙，不能') + '给予帮助')
	})
	hunterJin.subscribe(hunterPeter, function(){
		console.log('小金表示：给予帮助')
	})
	hunterZhang.subscribe(hunterPeter, function(){
		console.log('小金表示：给予帮助')
	})
	
	//Peter遇到困难，赏金198寻求帮助
	hunterPeter.publish(198)
	
	//猎人们(观察者)关联他们感兴趣的猎人(目标对象)，如Peter，当Peter有困难时，会自动通知给他们（观察者）

```
**发布订阅模式：**

```js
//定义一家猎人工会
//主要功能包括任务发布大厅(topics)，以及订阅任务(subscribe)，发布任务(publish)
let HunterUnion = {
	type: 'hunt',
	topics: Object.create(null),
	subscribe: function (topic, fn){
	    if(!this.topics[topic]){
	      	this.topics[topic] = [];  
	    }
	    this.topics[topic].push(fn);
	},
	publish: function (topic, money){
	    if(!this.topics[topic])
	      	return;
	    for(let fn of this.topics[topic]){
	    	fn(money)
	    }
	}
}

//定义一个猎人类
//包括姓名，级别
function Hunter(name, level){
	this.name = name
	this.level = level
}
//猎人可在猎人工会发布订阅任务
Hunter.prototype.subscribe = function (topic, fn){
	console.log(this.level + '猎人' + this.name + '订阅了狩猎' + topic + '的任务')
    HunterUnion.subscribe(topic, fn)
}
Hunter.prototype.publish = function (topic, money){
	console.log(this.level + '猎人' + this.name + '发布了狩猎' + topic + '的任务')
    HunterUnion.publish(topic, money)
}

//猎人工会走来了几个猎人
let hunterMing = new Hunter('小明', '黄金')
let hunterJin = new Hunter('小金', '白银')
let hunterZhang = new Hunter('小张', '黄金')
let hunterPeter = new Hunter('Peter', '青铜')

//小明，小金，小张分别订阅了狩猎tiger的任务
hunterMing.subscribe('tiger', function(money){
	console.log('小明表示：' + (money > 200 ? '' : '不') + '接取任务')
})
hunterJin.subscribe('tiger', function(money){
	console.log('小金表示：接取任务')
})
hunterZhang.subscribe('tiger', function(money){
	console.log('小张表示：接取任务')
})
//Peter订阅了狩猎sheep的任务
hunterPeter.subscribe('sheep', function(money){
	console.log('Peter表示：接取任务')
})

//Peter发布了狩猎tiger的任务
hunterPeter.publish('tiger', 198)

//猎人们发布(发布者)或订阅(观察者/订阅者)任务都是通过猎人工会(调度中心)关联起来的，他们没有直接的交流。
```
观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。

观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，这种处理方式比较直接粗暴，但是会造成代码的冗余。

而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰，消除了发布者和订阅者之间的依赖。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。

观察者模式是不是发布订阅模式
网上关于这个问题的回答，出现了两极分化，有认为发布订阅模式就是观察者模式的，也有认为观察者模式和发布订阅模式是真不一样的。

其实我不知道发布订阅模式是不是观察者模式，就像我不知道辨别模式的关键是设计意图还是设计结构（理念），虽然《JavaScript设计模式与开发实践》一书中说了分辨模式的关键是意图而不是结构。

如果以结构来分辨模式，发布订阅模式相比观察者模式多了一个中间件订阅器，所以发布订阅模式是不同于观察者模式的；如果以意图来分辨模式，他们都是实现了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新，那么他们就是同一种模式，发布订阅模式是在观察者模式的基础上做的优化升级。

不过，不管他们是不是同一个设计模式，他们的实现方式确实有差别，我们在使用的时候应该根据场景来判断选择哪个。